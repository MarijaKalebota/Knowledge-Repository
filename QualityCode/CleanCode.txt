"Clean code" from Clean Code
============================

Clean code is defined in the book by the same name written by Robert C. Martin as code that can be easily understood
and quickly read by programmers of the same knowledge level as the programer who wrote the clean code. Clean code
is written with the hope that it will allow programmers to more easily maintain it in the future.

Principles of clean code
------------------------
Meaningful names: if you have to assign a name, come up with a short name that clearly says what it does, how it is
used and why it exists; classes and objects should be nouns such as animals, lion; functions should be verbs such as
get, do; use solution domain names (as oppose to problem domain names); context around the names is as important as
the names themselves

Names should be descriptive; reveal intent.
Names should be meaningfully distinct.
Avoid encoding names.
Names should not have prefix or suffix.
Classes and object should be nouns; Customer, Account.
Methods should be verbs; Delete, Save.
Have a consistent lexicon; get or fetch, choose one.
Same name, same purpose, same semantics.
Use solution domain names; algorithm and pattern names.
Use problem domain names when there are no solution domain names.


Functions: make them small (around five lines long); should do only one thing, but what one thing is depends on the
level of abstraction; abstraction should be uniform within the same function; the most abstract functions should
read like English; functions should have as few arguments as possible (no more then three); don't pass flags as
arguments; when passing two or more arguments, order them; write the ordering of the arguments into the name of the
function; if a function takes many arguments, try to wrap some of them in a class or a structure; make it clear that
a function is an event and that it returns nothing; never return a value through the input argument, always return
a value through the return value; functions should have no side effects; functions should either return information
about an object or should change the state of the object, never both; if you handle errors with try/catch blocks,
make them invoke functions, so you can better separate error handling from the rest of the code

Comments: comment only if there is no other way of teaching others what your code does; they can be used to explain
intent, to clarify, as a note or as a warning

Formatting: write a file as a newspaper article, headline at the top, synopsis in the first paragraph; blank lines
should separate functions, similar concepts should be kept near each other; don't make files or lines too long

Objects and data structures: they are polar opposites; objects expose function and abstract data while data
structures expose data and don't care which functions handle them; use data structures (procedural programming) when
you will need to add new functions in the future; use object (object oriented programming) when you will need to add
new classes (data types, data structures) in the future; functions in a class should only call a small subset of
functions as described in the Law of Demeter

Error handling: separate error handling from the rest of the code with try and catch blocks; write tests that cause
errors (Test Driven Development); avoid unchecked exceptions like the plague itself; display informative messages
when handling exceptions; write exception classes that catch and translate errors; avoid returning null, return a
special case object or throw an exception

Boundaries: when using third party code, wrap it in your own code to ensure you can easily handle changes to it;
write tests for third party API to ensure you understand how it works (Learning Tests)

Unit tests: write a test before writing code (Test Driven Development); three laws of TDD are: write a failing test,
write the test until it can fail, write code until the test is passed; test code is as important as all other pieces
of code; tests allow you to make changes to the code without the fear of introducing mistakes; one assert per test;
test should be quick, independent of each other, repeatable in any environment, return boolean values and should be
written before any other code; sometimes it is alright to break the rules that you always apply to the rest of the
code if it will make your test code more readable

Classes: classes should be short and named after their responsibilities (we did this successfully if we can describe
the class without using or, but, if or and); systems should be made up of many small classes not a few large classes;
class cohesion means a lot of functions use a large portion of variables; classes must only have one reason to
change; classes should be isolated from external change

Systems: separate using from construction; TODO

Examples of how to code cleanly are showcased in case studies in chapters 14, 15 and 16

Rules and references: chapter 17

PATTERNS: abstract factory, special case pattern, adapter pattern, build operate check pattern, template method
pattern, strategy pattern, decorator